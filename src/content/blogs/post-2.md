---
title: "First Journey"
description: "This is the first post of my new blog."
author: "Wang Tech"
image:
  url: "../../assets/images/1.png"
  alt: "Walking on Mars - Generated by AI"
pubDate: 2025-11-27
tags:
  ["microservices", "spring boot", "K8S"]
---

Recently, our system faced a strange issue during a *rolling deployment*.

When *Customer A* books a ride, our system tries to assign a *Driver B*.  
We allow **up to 60 seconds** to find a driver.  
If no driver is found within **60 seconds**, we return *â€œDriver Not Foundâ€*.

Normally, everything works perfectly.

But during deployment, something went wrong...  
Some trips stayed in **WAITING** status for **120â€“180 seconds**,  
even though the timeout limit is only **60 seconds**. ğŸ˜³

---

## ğŸ¤” Why does this happen?

The system uses a **Virtual Thread** to handle timeouts.

- When a trip is created, a **timer thread** starts (e.g., 60s).
- If a driver is found â†’ we **interrupt** the timer (happy path).
- If no driver is found â†’ the timer triggers **driver-not-found** callback.
- This mechanism works well on all podsâ€¦ **until deployment happens.**

---

## ğŸš– Let's imagine the system like Grab

### ğŸ§ª Booking scenario

> *You are User A, booking a ride to Driver B*

                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚      User A book vehicle     â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚          SERVICE POD             â”‚
                  â”‚----------------------------------â”‚
                  â”‚ 1. Create trip â†’ WAITING         â”‚
                  â”‚ 2. Start countdown timer:        â”‚
                  â”‚    .sleep(60s) -> handleNotFound â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
                  (timeout counting...) 59 -> 58 -> 57 -> ... -> 0
                                  â”‚
                                  â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚              ROLLING DEPLOYMENT STARTS             â”‚
          â”‚       â€¢ Kubernets sends SIGTERM                    â”‚
          â”‚       â€¢ JVM shuts down                             â”‚
          â”‚       â€¢ ALL threads killed instantly               â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
                     âŒ **Timeout Thread Disappears**
                     âŒ No recovery logic
                     âŒ No callback fired
                                  â”‚
                                  â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   TRIP STUCK IN WAITING FOREVER                    â”‚
           â”‚   Client show not found driver                     â”‚
           â”‚   But server still waiting confirm from driver B,  â”‚
           â”‚   If driver accept the trip, the conplict occurred â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  
<br/>

---

## âš ï¸ Why this is dangerous?

| Client View | Backend Reality |
|-----------------|----------------------|
| Shows *Trip failed* | Trip still WAITING |
| User creates new trip | Older trip still listens |
| Driver accepts late | Conflict: trip already closed |

This causes:

- Ghost bookings ğŸ‘»  
- Double driver assignment ğŸš—ğŸš—  
- Broken user trust ğŸ˜©  
- Hard-to-debug production issues ğŸ§¯

---

## ğŸ’¡ Root cause

> We relied entirely on an **in-memory timeout thread**.  
> During deployment, the JVM was terminated, and the thread was **killed before it fired**.  
> No backup, no persistence, no recovery.

---

## ğŸš€ Next, how we fixed it (v2)

*(Coming in next article â€” using Redis ZSET + Recovery Worker to ensure timeout survives pod death)*  
